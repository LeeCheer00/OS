操作系统用做扩充机器。
没有任何软件支持的计算机称为裸机。它仅构成计算机系统的物资基础。
呈现在用户面前的计算机系统是经过若干层软件改造的计算机。
裸机在里层。
外面是操作系统，操作系统提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更加方便的机器。
覆盖了软件的机器称为扩充机器,又称为虚拟机。


单批量处理系统、多批量处理系统：多个程序同时进入内存并运行

实时操作系统
硬实时操作系统：飞行器
软实时操作系统：银行管理系统


网络操作系统
分布式计算机操作系统：同等地位 无主从机 资源共享 任意重构子系统 
用于管理分布式计算机系统的操作系统称为分布式计算机系统
分布性
并行性
相互协同完成同一个任务
http://c.biancheng.net/cpp/uploads/allimg/140629/1-14062Z02924339.jpg 
发展历程
嵌入式操作系统、服务器操作系统、多处理器操作系统



内核：
时钟管理：进程切换 衡量一个作业的运行程度
中断机制: 提高多道运行环境中cpu的利用率，主要针对外部设备 鼠标输入、keyinput、 process management调度、系统功能调度、设备驱动、文件访问、现代操作系统是靠中断驱动的软件。 中断机制中，只有一小部分属于内核，负责保护和恢复中断现场的信息，转移控制权到相关的处理程序 减少中断的处理时间，提高系统的并行处理能力

原语:底层是一些可被调用的公用小程序，它们各自完成一个规定的操作
1、它们处于操作系统的底层、最近接硬件的部分
2、运行具有原子性-其操作只能一气呵成 （安全性和便于管理考虑的）
3、运行时间都很短，调用频繁
系统控制的数据结构和处理
登记状态信息的数据结构有很多：
作业控制块、进程控制块pcb、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等
进程管理：进程状态管理、进程调度、分派、创建与撤销进程控制块
存储管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序
设备管理：缓冲区管理、设备分配和回收




综上：核心态指令实际上包括系统调用类指令和一些针对始终、中断和原语的操作指令
 
 ====
 核心态 和 用户态
 操作系统内核工作在核心态
 而用户程序工作在用户态
 http://c.biancheng.net/cpp/uploads/allimg/140629/1-14062Z13353613.png 
 中断: cpu执行指令以外的事件的发生，设备发出的i/o结束中断 表示设备输入/输出处理已经完成 处理机进入下一个 i/o请求 同时让完成i/o的程序继续运行 。 始终中断， 时间片一道，让处理机即使、启动定时运行的任务等 ， 它们与当前程序运行无关的事件，它们与当前处理机运行的程序无关 
 异常:内中断，trap， cpu执行指令内部的事件 
 非法操作码、地址越界、算术溢出、虚拟系统的却也以及抓们的陷入指令引起的事件
 一旦出现应立即处理，依赖与当前程序的运行现场，而且异常不能被屏蔽。


 所谓系统调用，就是用户在程序中调用操作系统所提供的一些子功能
 看做是特殊的公共子程序。
 进程控制：阻塞和唤醒
 系统核心态用户态的软件实现和切换，对于硬件层面的具体理解，参考《计算机组成原理》
 中断和异常机制进入核心态管理程序
 继续运行程序，保存的程序现场退出中断处理程序或者异常处理程序，返回断点处继续执行

用户态转核心态
用户程序要求操作系统的服务，即系统调用
发生一次中断
用户程序中产生了一个错误状态
用户程序中企图执行一条特权指令
从核心态转向用户态有一条指令实现，这条指令也是特权命令，一般是中断返回指令

用户态进入核心态，不仅仅是状态需要切换，而且，所使用的堆栈也可能需要由用户堆栈切换为系统堆栈， 但是这个系统堆栈也是属于该进程的。


====
大内核----高性能的系统服务，各管理模块之间共享信息，能有效利用相互之间的有效特性。性能优势
微内核----内核最基本功能保留在内核，不要核心态执行的功能移到用户态执行，从而降低了内核的设计复杂性
而那些一处内核的操作系统代码根据分层的原则
划分成若干服务程序，
执行独立，交互则借助于微内核进行通信


微内核结构有效地分离了内核与服务， 服务与服务，接口清晰，各部分独立地优化和演进， 从而保证操作系统的可靠性
但是，
频繁地核心态和用户态进行切换，操作系统的执行开销偏大。
频繁使用的系统服务又移回内核
从而保证系统性能

系统性能下降的主要因素不是体系结构
相互抵消

系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构成为库操作系统
并行性 多事件发生在同一时刻
并发性 多事件在同一时间间隔内发生


特权指令与非特权指令
少儿不宜
老少皆宜的区别
用户态转换为核心态的唯一途径是中断或异常


访管指令 基本功能是让程序拥有"自愿进管"从而引起访管中断
访管中断 访管中断处理程序，访管中断程序将系统调用的操作数和参数转到相应的例行子程序。
完成服务功能后，退出中断，返回到用户程序断点继续执行

每个进程都配置一个pcb对其进行描述，进程实体是由程序段、数据段、进程控制段三个部分组成的
创建状态 pcb填写控制管理进程的信息
就绪状态 等待处理机
阻塞状态 等待其他资源 等待i/o 当进程请求某一资源外设的使用和使用和分配
运行状态 每一刻最多只有一个进程处于运行状态
结束状态 进程从系统中消失


http://c.biancheng.net/cpp/uploads/allimg/140629/1-14062Z21T1A4.png 
就绪状态->运行状态
运行状态->就绪状态
运行状态->阻塞状态 
阻塞状态->就绪状态 i/o 操作结束或中断结束时， 中断处理程序必须把相应进程的状态由阻塞转换为就绪状态

进程控制模块
程序段
数据段


共享存储
 
消息传递
直接通信方式:
    间接通信方式:把进程发送到某个中间试题中，接收简称从中间实体中取得消息。信箱，信箱通信方式

管道通信:
    消息传递的一个特殊方式。
    所谓管道
    连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件访问向管道提供输入的发送进程
    以字符流形式将大量的数据送入管道
    管道输出的接收进程， 读进程， 则从管道中接收数据
    为了协调双方的通信，管道机制需具备以下三种协调能力：互斥、同步、确定对方的存在



======
线程
进程是为了 使得多道程序并发执行， 以提高资源利用率和系统吞吐量
而引入线程， 则是为了减少程序在并发执行时所付出的时空开销，提高操作系统的并发性能


直接理解： 轻量级进程程序执行流中的最小单元。cpu执行单元。
线程id、程序计数器、寄存器集合和堆栈组成
线程是进程的一个实体
被系统独立调度和分派的基本单位
线程自己不拥有系统资源，只拥有一点在运行中不可少的资源
它可以与同一个进程的其他线程共享进程所拥有的全部资源
一个线程可以创建和撤销另一个线程
同一个进程中的多个线程之间可以并发执行
由于线程之间的相互制约，致使线程在运行中呈现出间断性
线程有就绪，阻塞和运行三种基本状态， 进程则是创建、就绪、阻塞、运行、结束 五种状态
进程的地址空间之间相互独立，同一进程的各线程间共享进程 的资源
某进程内的线程对于其他进程不可见

通信方面： 进程间通信ipc 需要进程同步和互斥手段的辅助， 以保证数据的一致性
而线程间可以直接读/写进程数据段（如全局变量） 来进行通信


用户级线程 ，相关的线程管理工作都是应用程序完成，线程库，内核意识不到线程的存在
内核级线程又称为内核支持的线程 应用程序没有进行线程管理的代码, 线程管理的所有工作由内核完成，只有一个到内核级线程的编程接口。内核为进程及其内部的每一个线程维护上文信息，调度也是在内核基于线程架构的基础上完成


http://c.biancheng.net/cpp/uploads/allimg/140629/1-1406291220161Z.jpg 


多线程模型

多对一

多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。 
优点：线程管理在用户空间进行， 因而效率比较高
缺点：当一个线程在使用内核服务时被阻塞，那么整个进程会被阻塞，多个现场不能并行的运行在多处理机上


一对一
将每个用户级线程映射到一个内核级线程
优点：当一个线程被阻塞，允许另一个线程继续执行，所以并发能力强

缺点： 没创建一个用户级线程都需要创建一个内核级线程与其对应， 这样创建线程的开销较大，会影响到应用程序的性能


多对多
将n个用户级线程映射到m个内核级线程上，要求m<=n

折中的做法，克服多对一并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。  多对一和一对一的优点都集合在一起。

调度
作业调度 内存与辅存之间的调度
中级调度 提高内存利用率和系统吞吐量
进程调度 按照某些方法和策略从就绪队列中选取一个进程，将处理机分配给它
http://c.biancheng.net/cpp/uploads/allimg/140629/1-140629144600329.jpg 

进程调度方式
调度的时机、切换与过程
非剥夺调度方式 非抢占方式。 不适用于分时系统和大多数的实时系统
剥夺调度方式  抢占方式。


优先权、短进程优先和时间片原则，对提高系统吞吐量和响应效率有明显的好处。
但“剥夺”不是任意性行为。有原则性。


FCFS调度算法
先来先服务
FCFS调度算法属于不可剥夺算法
FCFS会使得后面许多短作业等待很长时间
对多个具有相同优先级的进程按照FCFS原则处理


简单但是效率低


cpu 繁忙型作业，而不利于i/o 繁忙型作业 


SJF 短作业优先调度算法
后备队列中选择一个若干运行时间最短的作业
将他们调入内存运行

对于长作业不利

SJF调度算法的平均等待时间、平均周转时间最少





优先级调度算法
非剥夺式优先级调度算法
剥夺式优先调度算法


优先级是否可以改变
进程创建后


静态优先级  创建就不变
动态优先级 进程过程中，动态调整优先级。 动态调整优先级的主要依据为进程占有cpu时间的长短、就绪进程等待cpu时间的长短。




高响应比优先调度算法



FCFS SJF 综合平衡
计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行



=====
时间片轮转调度算法


主要适用于分时系统


时间片太小， 处理机开销增大，而真正用于运行用户进程的时间将减少，时间片大小应该选择适当

时间片大小： 系统的响应时间、就绪队列中的进程数目和系统的处理能力

==========
多级反馈队列调度算法

http://c.biancheng.net/cpp/uploads/allimg/140629/1-140629155KQ11.jpg 


设置多个就绪队列
并为各个队列赋予不同的优先级
优先级越高的队列，进程的运行时间片就越小。

新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待，高优先级转到低优先级

第一级队列为空，第二级队列中的进程运行 以此类推
1～i-1级 均为空，才会调度第i级队列的进程运行

临界资源
临街资源的那段代码称为临界区
访问过程分为四个部分：
do {
    entry section;  //进入区
    critical section;  //临界区
    exit section;  //退出区
    remainder section;  //剩余区
} while( true )


同步亦称直接制约关系
A->B
输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A 
互斥

例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。


空闲让进
忙则等闲
有限等待
让权等待


管程的定义：
系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略了它们的内部结构和实现细节。管程是由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。 


管程组成


semaphore plate=l, apple=0, orange=0;
dad() {
    while(A) {
        prepare an apple; 
        P(plate); //互斥向盘中取，放水果
        put the apple on the plate; // 向盘中放苹果
        V(apple); //允许取苹果
    }
}

mom() {
    while(1) {
        prepare an orange ;
        P(plate); //互斥向盘中取、放水果
        put the orange on the plate; // 向盘中放橘子
        V(orange); //允许取橘子
    }
}

son() {
    while(1) { 
        P(orange); //互斥向盘中去橘子
        take an orange from the plate;
        V(plate); //允许盘中取、放水果 
        eat the orange;
    }
}


daughter() {
    while(1) {

        P(apple); // 互斥向盘中去苹果
        take an apple form the plate; 
        V(plate); //运行向盘中取、放水果 
        eat the apple;
    }
}


=====
读写互斥
int count=0; //
semaphore  mutex=1;
semaphore rw=1; // 
writer() {
    while(1){
        P(rw); //互斥访问共享文件
        Writing; //写入
        V(rw); //释放共享文件

    }
}


reader() {
    while(1){
        P(mutex); //互斥访问count变量
        if(cont==0)
            P(rw);
        count++;
        V(mutex);
        reading;
        P(mutex);
        count--;
        if (count==0)
            V(rw);
        V(mutex);
    }
}



====
写优先

int count=0;
semaphore mutex=1;
semaphore rw=1;
semaphore w=1; //用于实现 写优先 

writer() {
    while(1){
        P(w);
        P(rw);
        writing;
        V(rw);
        V(w);
    }
}


reader() {
    while(1){
        P(w);
        P(mutex);

        if (count==0) 
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading;
        P(mutex);
        count--;


        if(count==0)
            V(rw);


        V(mutex);
    }
}


===
哲学家吃饭问题
http://c.biancheng.net/cpp/uploads/allimg/140630/1-140630144622230.jpg 


信号量
Ch0Pstick[5]={1,1,1,1,1}



---
semaphore Chopstick[5]={1,1,1,1,1}

Pi(){
    do{
        P (chopstick[i]);
        P (chopstick[(i+1) % 5]);
        eat;
        V(chopstick[i]);
        V(chopstcik[(i+l)%5]);
        think;

    }while(1);

}



===

Correct answer
semaphore  chopstick[5]={1,1,1,1,1};
semaphore mutex=l;
Pi() {
    do {
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+l) % 5]);//取右筷子
        V(mutex);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+l) % 5]);
        think;
    }
}



======
三种元素 抽烟问题
胶水 烟草 纸


int random; //存储随机数
semaphore offerl=0; //定义信号量对应烟草和纸组合的资源
semaphore offer2=0; //定义信号量对应烟草和胶水组合的资源
semaphore offer3=0; //定义信号量对应胶水和纸组合的资源
semaphore finish=0; //定义信号量表示抽烟是否完成

//供应者

while(l){
    random = 任意整数随机数;
    random = random % 3;
    if(random==0)
        V(offerl); //提供烟草和纸
    else if(random==l)
        V(offer2); //提供烟草和胶水
    else
        V(offer3); //提供胶水和纸
    //任意两种材料放在桌子上
    P(finish);
    
}


//拥有烟草者
while(l){ 
    P(offer3);
    //拿值和胶水，卷成烟，抽掉。
    V(finish);
}

//拥有纸者
while(l){ 
    P(offer2);
    //拿烟草和胶水，卷成烟，抽掉。
    V(finish);
}
//拥有胶水者
while(l){ 
    P(offerl);
    //拿纸和烟草,卷成烟，抽掉。
    V(finish);
}



死锁

资源竞争


互斥条件
不剥夺条件
请求和保持条件
循环等待条件

资源分配图含圈而系统又不一定出现死锁的原因是同类资源数大于1
每类资源只有一个则资源分配图含圈就变成了系统出现死锁的充分必要条件
http://c.biancheng.net/cpp/uploads/allimg/140630/1-140630152010348.jpg http://c.biancheng.net/cpp/uploads/allimg/140630/1-140630152010348.jpg 



银行家算法


分配资源
超过最大可分配资源限度 就拒绝 宣布最大值
尚无足够资源Pi需要等待
安全性算法
http://c.biancheng.net/cpp/uploads/allimg/140630/1-1406301I940246.jpg 
请求边 ： 从进程到资源
分配边 ： 从资源到进程

不可简化的S状态资源分配图 为死锁定理
==========================
死锁的解除
1、资源剥夺法
2、撤销进程法
3、进程回退法 让一或多个进程回退足以回避死锁的底布，进程回退时自愿释放自愿而不是剥夺。设置还原点。


段号 页号 页内偏移量http://c.biancheng.net/cpp/uploads/allimg/140701/1-140F10123342B.jpg 

局部性原理
时间局部性: 如果程序中的某条指令一旦执行，不久以后该指令可能再次执行 某数据被访问，亦然，因为，程序中存在大量的循环操作。
空间局部性: 存储单元被访问，很快也会附近的存储单元也会被访问，可能集中在一定的地址范围内，指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。
